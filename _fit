#compdef fit

_fit() {
    local -a commands
    commands=(
        'rebase:sync and rebase onto a branch'
        'commit:create or amend a commit'
        'uncommit:remove last commit but keep changes'
        'push:commit, rebase, and force push'
        'log:display git log in custom format'
        'branch:fetch and checkout a branch'
        'new-branch:create a new branch with formatted name'
        'stash:stash changes with optional message'
        'stash-pop:apply and remove stash from list'
        'stash-apply:apply stash but keep in list'
        'stash-clear:delete all stashes'
        'setup:configure git identity and zsh completion'
        'help:display detailed help information'
    )

    local state
    _arguments -C \
        "1:command:->command" \
        "*::arg:->args"

    case $state in
        command)
            _describe 'fit command' commands
            ;;
        args)
            case $words[1] in
                rebase)
                    local -a branches
                    if command -v git >/dev/null 2>&1; then
                        branches=($(git branch -r --format='%(refname:short)' 2>/dev/null | sed 's|origin/||' | sort -u))
                        if [ ${#branches[@]} -gt 0 ]; then
                            _describe 'branch' branches
                        fi
                    fi
                    ;;
                branch)
                    local -a branches
                    local cache_file=""
                    if command -v brew >/dev/null 2>&1; then
                        local brew_prefix=$(brew --prefix 2>/dev/null)
                        if [ -n "$brew_prefix" ] && [ -f "$brew_prefix/opt/fit/.branch_cache" ]; then
                            cache_file="$brew_prefix/opt/fit/.branch_cache"
                        fi
                    fi
                    if [ -z "$cache_file" ] && [ -f "$HOME/.fit/.branch_cache" ]; then
                        cache_file="$HOME/.fit/.branch_cache"
                    fi
                    if [ -n "$cache_file" ] && [ -f "$cache_file" ]; then
                        branches=($(cat "$cache_file" 2>/dev/null))
                        if [ ${#branches[@]} -gt 0 ]; then
                            _describe 'branch' branches
                        fi
                    elif command -v git >/dev/null 2>&1; then
                        branches=($(git branch -r --format='%(refname:short)' 2>/dev/null | sed 's|origin/||' | sort -u))
                        if [ ${#branches[@]} -gt 0 ]; then
                            _describe 'branch' branches
                        fi
                    fi
                    ;;
                log)
                    ;;
                new-branch)
                    local -a identificators
                    identificators=(
                        'add:add new feature'
                        'change:modify existing feature'
                        'update:update existing feature'
                        'fix:fix bug or issue'
                        'refactor:refactor code'
                        'remove:remove feature or code'
                    )
                    if [[ ${#words[@]} -eq 2 ]]; then
                        _describe 'identificator' identificators
                    elif [[ ${#words[@]} -eq 3 ]]; then
                        _message 'commit message'
                    elif [[ ${#words[@]} -eq 4 ]] && [[ $words[(I)-id] -eq 0 ]]; then
                        _describe 'option' '-id:task identifier'
                    elif [[ $words[(I)-id] -gt 0 ]] && [[ ${#words[@]} -eq $words[(I)-id] ]]; then
                        _message 'task_id'
                    fi
                    ;;
                commit|push|stash)
                    _message
                    ;;
                uncommit|stash-pop|stash-apply|stash-clear)
                    ;;
            esac
            ;;
    esac
}
